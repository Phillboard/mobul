/**
 * AI Action Executor
 * 
 * Executes design actions generated by AI on the canvas.
 * Bridges AI suggestions to actual canvas state changes.
 */

import type {
  DesignAction,
  DesignElement,
  CanvasState,
} from '../types/designer';
import type { UseDesignerStateReturn } from '../hooks/useDesignerState';

// ============================================================================
// Position Utilities for AI
// ============================================================================

/**
 * Position shortcut type
 */
export type PositionShortcut = 
  | 'top-left' | 'top' | 'top-center' | 'top-right'
  | 'left' | 'center' | 'right'
  | 'bottom-left' | 'bottom' | 'bottom-center' | 'bottom-right';

/**
 * Convert a position shortcut to canvas coordinates
 */
export function positionToCoordinates(
  position: string | PositionShortcut,
  canvasWidth: number,
  canvasHeight: number,
  elementWidth: number,
  elementHeight: number,
  padding: number = 40
): { x: number; y: number } {
  const normalizedPosition = position.toLowerCase().trim();
  
  const positions: Record<string, { x: number; y: number }> = {
    'top-left': { 
      x: padding, 
      y: padding 
    },
    'top': { 
      x: (canvasWidth - elementWidth) / 2, 
      y: padding 
    },
    'top-center': { 
      x: (canvasWidth - elementWidth) / 2, 
      y: padding 
    },
    'top-right': { 
      x: canvasWidth - elementWidth - padding, 
      y: padding 
    },
    'left': { 
      x: padding, 
      y: (canvasHeight - elementHeight) / 2 
    },
    'center': { 
      x: (canvasWidth - elementWidth) / 2, 
      y: (canvasHeight - elementHeight) / 2 
    },
    'right': { 
      x: canvasWidth - elementWidth - padding, 
      y: (canvasHeight - elementHeight) / 2 
    },
    'bottom-left': { 
      x: padding, 
      y: canvasHeight - elementHeight - padding 
    },
    'bottom': { 
      x: (canvasWidth - elementWidth) / 2, 
      y: canvasHeight - elementHeight - padding 
    },
    'bottom-center': { 
      x: (canvasWidth - elementWidth) / 2, 
      y: canvasHeight - elementHeight - padding 
    },
    'bottom-right': { 
      x: canvasWidth - elementWidth - padding, 
      y: canvasHeight - elementHeight - padding 
    },
  };

  return positions[normalizedPosition] || positions['center'];
}

/**
 * Get default element dimensions by type
 */
export function getDefaultElementSize(type: string): { width: number; height: number } {
  const sizes: Record<string, { width: number; height: number }> = {
    'text': { width: 300, height: 50 },
    'headline': { width: 500, height: 60 },
    'subheading': { width: 400, height: 40 },
    'body': { width: 350, height: 100 },
    'image': { width: 200, height: 200 },
    'shape': { width: 150, height: 150 },
    'qr-code': { width: 150, height: 150 },
    'template-token': { width: 200, height: 40 },
    'button': { width: 180, height: 48 },
  };

  return sizes[type] || { width: 200, height: 100 };
}

/**
 * Create a default element with smart positioning
 */
export function createDefaultElement(
  type: string,
  canvasState: CanvasState,
  options?: {
    position?: string;
    content?: string;
    styles?: Record<string, any>;
  }
): Partial<DesignElement> {
  const size = getDefaultElementSize(type);
  const position = options?.position 
    ? positionToCoordinates(options.position, canvasState.width, canvasState.height, size.width, size.height)
    : findAvailablePosition(canvasState, size.width, size.height);

  const baseElement = {
    type,
    x: position.x,
    y: position.y,
    width: size.width,
    height: size.height,
    rotation: 0,
    locked: false,
    visible: true,
    styles: options?.styles || {},
  };

  // Add type-specific defaults
  switch (type) {
    case 'text':
      return {
        ...baseElement,
        content: options?.content || 'New Text',
        styles: {
          fontSize: 16,
          fontFamily: 'Arial',
          fontWeight: 'normal',
          color: '#000000',
          ...options?.styles,
        },
      };

    case 'headline':
      return {
        ...baseElement,
        type: 'text',
        content: options?.content || 'Your Headline',
        width: 500,
        height: 60,
        styles: {
          fontSize: 32,
          fontFamily: 'Arial',
          fontWeight: 'bold',
          color: '#000000',
          ...options?.styles,
        },
      };

    case 'subheading':
      return {
        ...baseElement,
        type: 'text',
        content: options?.content || 'Your subheading text',
        width: 400,
        height: 40,
        styles: {
          fontSize: 18,
          fontFamily: 'Arial',
          fontWeight: 'normal',
          color: '#666666',
          ...options?.styles,
        },
      };

    case 'qr-code':
      return {
        ...baseElement,
        data: '{{purl}}',
        foregroundColor: '#000000',
        backgroundColor: '#ffffff',
      };

    case 'template-token':
      return {
        ...baseElement,
        tokenContent: {
          token: options?.content || '{{first_name}}',
          fallback: '',
          transform: 'none',
        },
        styles: {
          fontSize: 16,
          color: '#4F46E5',
          ...options?.styles,
        },
      };

    default:
      return baseElement;
  }
}

/**
 * Execute a single design action
 */
export function executeDesignAction(
  action: DesignAction,
  designerState: UseDesignerStateReturn
): void {
  switch (action.type) {
    case 'add-element':
      if (action.element) {
        designerState.addElement(action.element);
      }
      break;

    case 'update-element':
      if (action.id && action.updates) {
        designerState.updateElement(action.id, action.updates);
      }
      break;

    case 'delete-element':
      if (action.id) {
        designerState.deleteElement(action.id);
      }
      break;

    case 'move-element':
      if (action.id && typeof action.x === 'number' && typeof action.y === 'number') {
        designerState.updateElement(action.id, {
          x: action.x,
          y: action.y,
        });
      }
      break;

    case 'resize-element':
      if (
        action.id &&
        typeof action.width === 'number' &&
        typeof action.height === 'number'
      ) {
        designerState.updateElement(action.id, {
          width: action.width,
          height: action.height,
        });
      }
      break;

    case 'set-background':
      if (action.imageUrl) {
        designerState.setBackgroundImage(action.imageUrl);
      } else if (action.color) {
        designerState.setBackgroundColor(action.color);
      }
      break;

    case 'clear-canvas':
      designerState.resetCanvas();
      break;

    case 'generate-background':
      // This action requires async image generation via DALL-E
      // It cannot be executed synchronously - the parent component should handle this
      // by checking for generate-background actions and calling ai.generateImage()
      console.log('[ActionExecutor] generate-background action detected:', action);
      console.warn('[ActionExecutor] generate-background requires async handling by parent component');
      // The action is valid but needs special handling outside this executor
      break;

    default:
      console.warn(`Unknown action type:`, action);
  }
}

/**
 * Execute multiple design actions
 */
export function executeDesignActions(
  actions: DesignAction[],
  designerState: UseDesignerStateReturn
): {
  executed: number;
  failed: number;
  errors: Array<{ action: DesignAction; error: string }>;
} {
  const errors: Array<{ action: DesignAction; error: string }> = [];
  let executed = 0;

  actions.forEach((action) => {
    try {
      executeDesignAction(action, designerState);
      executed++;
    } catch (error: any) {
      errors.push({
        action,
        error: error.message || 'Unknown error',
      });
    }
  });

  return {
    executed,
    failed: errors.length,
    errors,
  };
}

/**
 * Validate that an action can be executed
 */
export function canExecuteAction(
  action: DesignAction,
  canvasState: CanvasState
): { canExecute: boolean; reason?: string } {
  switch (action.type) {
    case 'add-element':
      if (!action.element) {
        return { canExecute: false, reason: 'No element data provided' };
      }
      // Check if position is within canvas bounds
      const x = action.element.x ?? 0;
      const y = action.element.y ?? 0;
      if (x < 0 || x > canvasState.width || y < 0 || y > canvasState.height) {
        return {
          canExecute: false,
          reason: 'Element position outside canvas bounds',
        };
      }
      break;

    case 'update-element':
    case 'delete-element':
    case 'move-element':
    case 'resize-element':
      if (!action.id) {
        return { canExecute: false, reason: 'No element ID provided' };
      }
      const elementExists = canvasState.elements.some(el => el.id === action.id);
      if (!elementExists) {
        return { canExecute: false, reason: `Element ${action.id} not found` };
      }
      break;

    case 'set-background':
      if (!action.imageUrl && !action.color) {
        return {
          canExecute: false,
          reason: 'No image URL or color provided',
        };
      }
      break;

    case 'clear-canvas':
      // Always allowed
      break;

    default:
      return { canExecute: false, reason: `Unknown action type` };
  }

  return { canExecute: true };
}

/**
 * Preview what actions will do (without executing)
 */
export function previewActions(
  actions: DesignAction[],
  canvasState: CanvasState
): {
  summary: string;
  details: string[];
  warnings: string[];
} {
  const details: string[] = [];
  const warnings: string[] = [];

  actions.forEach((action, index) => {
    const validation = canExecuteAction(action, canvasState);
    
    if (!validation.canExecute) {
      warnings.push(`Action ${index + 1}: ${validation.reason}`);
      return;
    }

    switch (action.type) {
      case 'add-element':
        const type = action.element?.type || 'unknown';
        details.push(`Add ${type} element`);
        break;

      case 'update-element':
        const updateKeys = Object.keys(action.updates || {});
        details.push(`Update element: ${updateKeys.join(', ')}`);
        break;

      case 'delete-element':
        details.push(`Delete element ${action.id}`);
        break;

      case 'move-element':
        details.push(`Move element to (${action.x}, ${action.y})`);
        break;

      case 'resize-element':
        details.push(`Resize element to ${action.width}x${action.height}`);
        break;

      case 'set-background':
        if (action.imageUrl) {
          details.push(`Set background image`);
        } else {
          details.push(`Set background color to ${action.color}`);
        }
        break;

      case 'clear-canvas':
        details.push(`Clear all elements from canvas`);
        warnings.push(`This will remove all existing elements!`);
        break;
    }
  });

  const summary = `${actions.length} action(s): ${details.slice(0, 3).join(', ')}${
    details.length > 3 ? `, and ${details.length - 3} more` : ''
  }`;

  return {
    summary,
    details,
    warnings,
  };
}

/**
 * Smart positioning for AI-added elements
 * Finds a good position that doesn't overlap existing elements
 */
export function findAvailablePosition(
  canvasState: CanvasState,
  elementWidth: number,
  elementHeight: number,
  preferredX?: number,
  preferredY?: number
): { x: number; y: number } {
  const padding = 20;
  const gridSize = 50; // Check positions in 50px increments

  // If preferred position provided and doesn't overlap, use it
  if (preferredX !== undefined && preferredY !== undefined) {
    if (
      !hasOverlap(
        { x: preferredX, y: preferredY, width: elementWidth, height: elementHeight },
        canvasState.elements
      )
    ) {
      return { x: preferredX, y: preferredY };
    }
  }

  // Try positions in a grid pattern
  for (let y = padding; y < canvasState.height - elementHeight - padding; y += gridSize) {
    for (let x = padding; x < canvasState.width - elementWidth - padding; x += gridSize) {
      if (
        !hasOverlap(
          { x, y, width: elementWidth, height: elementHeight },
          canvasState.elements
        )
      ) {
        return { x, y };
      }
    }
  }

  // If no available position found, just use bottom right with offset
  return {
    x: canvasState.width - elementWidth - padding,
    y: canvasState.height - elementHeight - padding,
  };
}

/**
 * Check if a position overlaps with existing elements
 */
function hasOverlap(
  rect: { x: number; y: number; width: number; height: number },
  elements: DesignElement[]
): boolean {
  return elements.some(el => {
    return !(
      rect.x + rect.width < el.x ||
      rect.x > el.x + el.width ||
      rect.y + rect.height < el.y ||
      rect.y > el.y + el.height
    );
  });
}

/**
 * Optimize action sequence
 * Reorder and combine actions for better execution
 */
export function optimizeActions(actions: DesignAction[]): DesignAction[] {
  // Group actions by type
  const adds = actions.filter(a => a.type === 'add-element');
  const updates = actions.filter(a => a.type === 'update-element');
  const deletes = actions.filter(a => a.type === 'delete-element');
  const others = actions.filter(
    a => !['add-element', 'update-element', 'delete-element'].includes(a.type)
  );

  // Combine multiple updates to same element
  const combinedUpdates = new Map<string, DesignAction>();
  updates.forEach(action => {
    if (!action.id) return;
    
    const existing = combinedUpdates.get(action.id);
    if (existing) {
      // Merge updates
      combinedUpdates.set(action.id, {
        ...existing,
        updates: {
          ...existing.updates,
          ...action.updates,
        },
      });
    } else {
      combinedUpdates.set(action.id, action);
    }
  });

  // Optimal order: deletes → others → adds → updates
  return [
    ...deletes,
    ...others,
    ...adds,
    ...Array.from(combinedUpdates.values()),
  ];
}

/**
 * Undo a set of actions
 * Returns reverse actions that undo the original actions
 */
export function createUndoActions(
  actions: DesignAction[],
  previousState: CanvasState
): DesignAction[] {
  const undoActions: DesignAction[] = [];

  actions.forEach(action => {
    switch (action.type) {
      case 'add-element':
        // Undo add by deleting the element
        if (action.element?.id) {
          undoActions.push({
            type: 'delete-element',
            id: action.element.id,
          });
        }
        break;

      case 'delete-element':
        // Undo delete by re-adding the element
        const deletedElement = previousState.elements.find(
          el => el.id === action.id
        );
        if (deletedElement) {
          undoActions.push({
            type: 'add-element',
            element: deletedElement,
          });
        }
        break;

      case 'update-element':
        // Undo update by reverting to previous values
        const previousElement = previousState.elements.find(
          el => el.id === action.id
        );
        if (previousElement && action.updates) {
          const revertUpdates: any = {};
          Object.keys(action.updates).forEach(key => {
            revertUpdates[key] = (previousElement as any)[key];
          });
          undoActions.push({
            type: 'update-element',
            id: action.id,
            updates: revertUpdates,
          });
        }
        break;

      // Other action types can be added as needed
    }
  });

  return undoActions.reverse(); // Reverse order for proper undo
}

