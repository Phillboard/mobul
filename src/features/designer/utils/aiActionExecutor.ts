/**
 * AI Action Executor
 * 
 * Executes design actions generated by AI on the canvas.
 * Bridges AI suggestions to actual canvas state changes.
 */

import type {
  DesignAction,
  DesignElement,
  CanvasState,
} from '../types/designer';
import type { UseDesignerStateReturn } from '../hooks/useDesignerState';

/**
 * Execute a single design action
 */
export function executeDesignAction(
  action: DesignAction,
  designerState: UseDesignerStateReturn
): void {
  switch (action.type) {
    case 'add-element':
      if (action.element) {
        designerState.addElement(action.element);
      }
      break;

    case 'update-element':
      if (action.id && action.updates) {
        designerState.updateElement(action.id, action.updates);
      }
      break;

    case 'delete-element':
      if (action.id) {
        designerState.deleteElement(action.id);
      }
      break;

    case 'move-element':
      if (action.id && typeof action.x === 'number' && typeof action.y === 'number') {
        designerState.updateElement(action.id, {
          x: action.x,
          y: action.y,
        });
      }
      break;

    case 'resize-element':
      if (
        action.id &&
        typeof action.width === 'number' &&
        typeof action.height === 'number'
      ) {
        designerState.updateElement(action.id, {
          width: action.width,
          height: action.height,
        });
      }
      break;

    case 'set-background':
      if (action.imageUrl) {
        designerState.setBackgroundImage(action.imageUrl);
      } else if (action.color) {
        designerState.setBackgroundColor(action.color);
      }
      break;

    case 'clear-canvas':
      designerState.resetCanvas();
      break;

    default:
      console.warn(`Unknown action type:`, action);
  }
}

/**
 * Execute multiple design actions
 */
export function executeDesignActions(
  actions: DesignAction[],
  designerState: UseDesignerStateReturn
): {
  executed: number;
  failed: number;
  errors: Array<{ action: DesignAction; error: string }>;
} {
  const errors: Array<{ action: DesignAction; error: string }> = [];
  let executed = 0;

  actions.forEach((action) => {
    try {
      executeDesignAction(action, designerState);
      executed++;
    } catch (error: any) {
      errors.push({
        action,
        error: error.message || 'Unknown error',
      });
    }
  });

  return {
    executed,
    failed: errors.length,
    errors,
  };
}

/**
 * Validate that an action can be executed
 */
export function canExecuteAction(
  action: DesignAction,
  canvasState: CanvasState
): { canExecute: boolean; reason?: string } {
  switch (action.type) {
    case 'add-element':
      if (!action.element) {
        return { canExecute: false, reason: 'No element data provided' };
      }
      // Check if position is within canvas bounds
      const x = action.element.x ?? 0;
      const y = action.element.y ?? 0;
      if (x < 0 || x > canvasState.width || y < 0 || y > canvasState.height) {
        return {
          canExecute: false,
          reason: 'Element position outside canvas bounds',
        };
      }
      break;

    case 'update-element':
    case 'delete-element':
    case 'move-element':
    case 'resize-element':
      if (!action.id) {
        return { canExecute: false, reason: 'No element ID provided' };
      }
      const elementExists = canvasState.elements.some(el => el.id === action.id);
      if (!elementExists) {
        return { canExecute: false, reason: `Element ${action.id} not found` };
      }
      break;

    case 'set-background':
      if (!action.imageUrl && !action.color) {
        return {
          canExecute: false,
          reason: 'No image URL or color provided',
        };
      }
      break;

    case 'clear-canvas':
      // Always allowed
      break;

    default:
      return { canExecute: false, reason: `Unknown action type` };
  }

  return { canExecute: true };
}

/**
 * Preview what actions will do (without executing)
 */
export function previewActions(
  actions: DesignAction[],
  canvasState: CanvasState
): {
  summary: string;
  details: string[];
  warnings: string[];
} {
  const details: string[] = [];
  const warnings: string[] = [];

  actions.forEach((action, index) => {
    const validation = canExecuteAction(action, canvasState);
    
    if (!validation.canExecute) {
      warnings.push(`Action ${index + 1}: ${validation.reason}`);
      return;
    }

    switch (action.type) {
      case 'add-element':
        const type = action.element?.type || 'unknown';
        details.push(`Add ${type} element`);
        break;

      case 'update-element':
        const updateKeys = Object.keys(action.updates || {});
        details.push(`Update element: ${updateKeys.join(', ')}`);
        break;

      case 'delete-element':
        details.push(`Delete element ${action.id}`);
        break;

      case 'move-element':
        details.push(`Move element to (${action.x}, ${action.y})`);
        break;

      case 'resize-element':
        details.push(`Resize element to ${action.width}x${action.height}`);
        break;

      case 'set-background':
        if (action.imageUrl) {
          details.push(`Set background image`);
        } else {
          details.push(`Set background color to ${action.color}`);
        }
        break;

      case 'clear-canvas':
        details.push(`Clear all elements from canvas`);
        warnings.push(`This will remove all existing elements!`);
        break;
    }
  });

  const summary = `${actions.length} action(s): ${details.slice(0, 3).join(', ')}${
    details.length > 3 ? `, and ${details.length - 3} more` : ''
  }`;

  return {
    summary,
    details,
    warnings,
  };
}

/**
 * Smart positioning for AI-added elements
 * Finds a good position that doesn't overlap existing elements
 */
export function findAvailablePosition(
  canvasState: CanvasState,
  elementWidth: number,
  elementHeight: number,
  preferredX?: number,
  preferredY?: number
): { x: number; y: number } {
  const padding = 20;
  const gridSize = 50; // Check positions in 50px increments

  // If preferred position provided and doesn't overlap, use it
  if (preferredX !== undefined && preferredY !== undefined) {
    if (
      !hasOverlap(
        { x: preferredX, y: preferredY, width: elementWidth, height: elementHeight },
        canvasState.elements
      )
    ) {
      return { x: preferredX, y: preferredY };
    }
  }

  // Try positions in a grid pattern
  for (let y = padding; y < canvasState.height - elementHeight - padding; y += gridSize) {
    for (let x = padding; x < canvasState.width - elementWidth - padding; x += gridSize) {
      if (
        !hasOverlap(
          { x, y, width: elementWidth, height: elementHeight },
          canvasState.elements
        )
      ) {
        return { x, y };
      }
    }
  }

  // If no available position found, just use bottom right with offset
  return {
    x: canvasState.width - elementWidth - padding,
    y: canvasState.height - elementHeight - padding,
  };
}

/**
 * Check if a position overlaps with existing elements
 */
function hasOverlap(
  rect: { x: number; y: number; width: number; height: number },
  elements: DesignElement[]
): boolean {
  return elements.some(el => {
    return !(
      rect.x + rect.width < el.x ||
      rect.x > el.x + el.width ||
      rect.y + rect.height < el.y ||
      rect.y > el.y + el.height
    );
  });
}

/**
 * Optimize action sequence
 * Reorder and combine actions for better execution
 */
export function optimizeActions(actions: DesignAction[]): DesignAction[] {
  // Group actions by type
  const adds = actions.filter(a => a.type === 'add-element');
  const updates = actions.filter(a => a.type === 'update-element');
  const deletes = actions.filter(a => a.type === 'delete-element');
  const others = actions.filter(
    a => !['add-element', 'update-element', 'delete-element'].includes(a.type)
  );

  // Combine multiple updates to same element
  const combinedUpdates = new Map<string, DesignAction>();
  updates.forEach(action => {
    if (!action.id) return;
    
    const existing = combinedUpdates.get(action.id);
    if (existing) {
      // Merge updates
      combinedUpdates.set(action.id, {
        ...existing,
        updates: {
          ...existing.updates,
          ...action.updates,
        },
      });
    } else {
      combinedUpdates.set(action.id, action);
    }
  });

  // Optimal order: deletes → others → adds → updates
  return [
    ...deletes,
    ...others,
    ...adds,
    ...Array.from(combinedUpdates.values()),
  ];
}

/**
 * Undo a set of actions
 * Returns reverse actions that undo the original actions
 */
export function createUndoActions(
  actions: DesignAction[],
  previousState: CanvasState
): DesignAction[] {
  const undoActions: DesignAction[] = [];

  actions.forEach(action => {
    switch (action.type) {
      case 'add-element':
        // Undo add by deleting the element
        if (action.element?.id) {
          undoActions.push({
            type: 'delete-element',
            id: action.element.id,
          });
        }
        break;

      case 'delete-element':
        // Undo delete by re-adding the element
        const deletedElement = previousState.elements.find(
          el => el.id === action.id
        );
        if (deletedElement) {
          undoActions.push({
            type: 'add-element',
            element: deletedElement,
          });
        }
        break;

      case 'update-element':
        // Undo update by reverting to previous values
        const previousElement = previousState.elements.find(
          el => el.id === action.id
        );
        if (previousElement && action.updates) {
          const revertUpdates: any = {};
          Object.keys(action.updates).forEach(key => {
            revertUpdates[key] = (previousElement as any)[key];
          });
          undoActions.push({
            type: 'update-element',
            id: action.id,
            updates: revertUpdates,
          });
        }
        break;

      // Other action types can be added as needed
    }
  });

  return undoActions.reverse(); // Reverse order for proper undo
}

